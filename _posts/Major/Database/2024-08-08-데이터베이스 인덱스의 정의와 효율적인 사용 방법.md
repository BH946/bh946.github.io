---
title:  "데이터베이스 인덱스의 정의와 효율적인 사용 방법"
categories : [Database]
tag : [데이터베이스,인덱스,성능최적화,B+Tree,검색속도,SQL]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
typora-root-url: ../../..
---



**데이터베이스 인덱스는 테이블 데이터를 빠르게 검색하기 위한 자료구조로, 적절히 사용하면 쿼리 성능을 크게 향상시키지만 잘못 사용하면 오히려 성능 저하를 가져올 수 있는 양면성을 가진 데이터베이스 객체다.**

<br>

<br>

## 인덱스의 정의와 원리

인덱스는 데이터베이스 테이블에 있는 데이터를 빠르게 찾기 위한 데이터베이스 객체다. 책의 목차나 색인과 유사한 개념으로, 원하는 정보를 빠르게 찾을 수 있도록 도와준다.

<br><br>

### 인덱스의 작동 원리

인덱스는 테이블의 특정 컬럼에 대해 생성되며, 해당 컬럼의 값과 해당 레코드가 저장된 물리적 주소를 key-value 쌍으로 저장한다. 이 정보는 정렬된 상태로 유지되어 빠른 검색이 가능하다.

```
인덱스 구조 예시:
[컬럼 값] - [물리적 주소]
"Apple" - 0x1234
"Banana" - 0x2345
"Cherry" - 0x3456
```

<span style="color:#ff9300">인덱스의 핵심은 정렬된 형태를 유지한다는 점이다. 이로 인해 전체 테이블을 스캔하지 않고도 조건에 맞는 데이터를 빠르게 찾을 수 있다.</span>

<br><br>

### 인덱스의 자료구조

대부분의 DBMS는 B-Tree 또는 B+Tree 구조를 인덱스 구현에 사용한다. 이 자료구조는 균형 잡힌 트리 구조로, 데이터 검색, 삽입, 삭제 작업을 효율적으로 수행할 수 있다.

B+Tree의 특징:

- 리프 노드만 데이터를 저장하고 나머지 노드는 인덱스 역할
- 리프 노드들은 연결 리스트로 연결되어 순차 검색에 효율적
- 트리의 높이가 낮아 검색 속도가 빠름

💡 **해시 테이블은 등호(=) 연산에는 최적화되어 있지만, 부등호(<, >) 연산이 자주 사용되는 데이터베이스에서는 B+Tree가 더 적합하다.**

<br>

<br>

## 인덱스의 장점과 단점

인덱스는 데이터베이스 성능에 큰 영향을 미치므로 장단점을 잘 이해하고 사용해야 한다.

**장점**

1. **검색 속도 향상**: 테이블 전체를 스캔하지 않고 인덱스를 통해 빠르게 데이터를 찾을 수 있다.
2. **시스템 부하 감소**: 효율적인 검색으로 CPU와 메모리 사용량이 줄어든다.
3. **정렬 및 그룹화 성능 향상**: ORDER BY, GROUP BY 연산이 빨라진다.
4. **전체 시스템 성능 향상**: 개별 쿼리 성능 향상이 전체 시스템 성능 향상으로 이어진다.

**단점**

1. **추가 저장 공간 필요**: 인덱스는 데이터베이스 크기의 약 10% 정도의 추가 공간을 차지한다.
2. **인덱스 생성 시간**: 대용량 테이블에 인덱스를 생성할 때 상당한 시간이 소요될 수 있다.
3. **데이터 변경 작업 성능 저하**: INSERT, UPDATE, DELETE 작업 시 인덱스도 함께 업데이트해야 하므로 성능이 저하될 수 있다.
4. **잘못된 사용 시 성능 저하**: 부적절한 인덱스 사용은 오히려 성능을 떨어뜨릴 수 있다.

<span style="color:#ff9300">인덱스는 데이터 조회가 많고 변경이 적은 환경에서 가장 효과적이며, 데이터 변경이 빈번한 환경에서는 신중하게 사용해야 한다.</span>

<br>

<br>

## 보편적인 인덱스 사용 기준

인덱스를 효과적으로 사용하기 위한 기준은 다음과 같다.

| 인덱스 사용하는 경우                 | 인덱스 사용 안 하는 경우             |
| ------------------------------------ | ------------------------------------ |
| 테이블 행의 개수가 많을 때           | 테이블 행의 개수가 적을 때           |
| WHERE문에 해당 컬럼이 많이 사용될 때 | WHERE문에 해당 컬럼이 적게 사용될 때 |
| 검색 결과가 전체의 2~4% 정도일 때    | 검색 결과가 전체의 10~15% 이상일 때  |
| 조인에 자주 사용되는 컬럼일 때       | DML 작업이 많이 일어나는 경우        |
| NULL을 포함하는 컬럼이 많을 경우     | 데이터의 중복도가 높은 컬럼일 때     |

<br><br>

### 인덱스 생성이 효과적인 경우

1. **대용량 테이블**: 행의 수가 많을수록 인덱스의 효과가 커진다.
2. **높은 선택도**: 데이터의 중복이 적고 고유한 값이 많은 컬럼에 효과적이다.
3. **자주 조회되는 컬럼**: WHERE 절이나 JOIN 조건에 자주 사용되는 컬럼에 인덱스를 생성한다.
4. **정렬이 필요한 컬럼**: ORDER BY에 자주 사용되는 컬럼에 인덱스를 생성하면 정렬 비용을 줄일 수 있다.

⚡ **인덱스는 검색 결과가 전체 데이터의 2~4% 정도일 때 가장 효율적이다. 검색 결과가 많아질수록 인덱스의 효율성이 떨어진다.**

<br><br>

### 인덱스 생성을 피해야 하는 경우

1. **소규모 테이블**: 행의 수가 적은 테이블은 전체 스캔이 더 효율적일 수 있다.
2. **낮은 선택도**: 성별처럼 값의 종류가 적은 컬럼은 인덱스 효율이 낮다.
3. **자주 변경되는 컬럼**: INSERT, UPDATE, DELETE가 빈번한 컬럼은 인덱스 유지 비용이 높다.
4. **대량의 결과 반환**: 검색 결과가 전체 데이터의 10~15% 이상이면 인덱스보다 전체 스캔이 효율적일 수 있다.

<br>

<br>

## 효율적인 인덱스 사용 방법

1. **복합 인덱스 고려**: 여러 컬럼이 함께 사용되는 경우 복합 인덱스를 고려한다.
2. **인덱스 컬럼 변형 주의**: WHERE 절에서 인덱스 컬럼을 함수로 변형하면 인덱스가 사용되지 않을 수 있다.
3. **정기적인 인덱스 재구성**: 데이터 변경이 많은 테이블은 정기적으로 인덱스를 재구성하여 성능을 유지한다.
4. **불필요한 인덱스 제거**: 사용되지 않는 인덱스는 제거하여 시스템 부하를 줄인다.

<span style="color:#777777">인덱스는 데이터베이스 성능 최적화의 핵심 요소지만, 무분별한 사용은 오히려 성능 저하를 가져올 수 있다. 데이터의 특성과 쿼리 패턴을 고려하여 적절한 인덱스 전략을 수립하는 것이 중요하다.</span>
