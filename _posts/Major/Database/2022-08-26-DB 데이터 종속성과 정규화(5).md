---
title:  "DB 데이터 종속성과 정규화(5)"
categories : [Database]
tag : [데이터베이스, 제1정규형, 제2정규형, 제3정규형, 제4정규형, 제5정규형, BCNF, 완전함수종속, 부분함수종속, 이행함수종속, 다치종속, 조인종속]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
---



데이터베이스의 종속성과 정규화 과정을 설명합니다. 삭제/삽입/갱신 이상 현상의 원인, 함수종속(완전/부분/이행), 다치종속, 조인종속의 개념, 그리고 제1정규형부터 제5정규형까지의 정규화 단계와 역정규화 기법을 체계적으로 다루고 있습니다.

<br>

## 데이터 종속성과 정규화

### 3종류 이상

* `삭제 이상`(정보손실)
  * 예시로 200번 학생이 'C123'의 과목 번호와, 3학년이라는 정보를 함께 가진다고 가정하자.
  * 'C123' 등록을 취소한다면?  
     ⇒ 3학년이라는 정보도 함께 삭제됨(`삭제 이상`)
* `삽입 이상`(정보 강제삽입)
  * 예시로 과목 번호가 기본키라고 가정하자.
  * 600번 학생이 2학년이라는 사실을 삽입한다면?   
    ⇒ 어떤 과목 번호를 등록하지 않는 한 삽입이 불가능(`삽입 이상`)
* `갱신 이상`(정보의 모순성)
  * 400번 학생의 투플(데이터)가 4개 있다고 가정하자.
  * 400번 학생의 학년을 4에서 3으로 하나만 변경  
    ⇒ 400번 학생에 대한 4개의 투플 모두를 변경해야 함(`갱신 이상`)

<br>

데이터가 보통 `종속성`이 있으니까 이렇게 `이상`이 발생하는 것이다.  
`정규화`는 이런 종속성을 없애주기 위해 데이터를 `분할` 하는 과정이라 할 수 있다.

* 즉, 이상의 해결은 정규화 과정이라 할 수 있다.
* 스키마 변환(조건에 맞게 릴레이션 분할) = 정규화 과정과 유사

<br><br>

### 정규화를 위한 개념

**함수 종속(FD)** : `X->Y`(X는 결정자, Y는 종속자) 

* Y는 X에 종속 + 최대 **하나만** 연관!

* 예시 : `“학번->학년”` 은 `“학생은 한 학년에만 속한다”` - 의미적 제약조건

**함수 종속의 추론 규칙(수학과 유사)** - 반사, 첨가, 이행, 분해, 결합

**함수 종속 다이어그램(FDD)**

* 함수 관계의 표현 (정규형 문제시 FDD를 그려서 확인!)
* FDD를 그리면 훨씬 정규형을 구하기 쉬우므로 이부분은 따로 정리하지 않으니 구글링을 통해 확인.

<br>

**완전함수종속** : X’⊂ X 이고 X’ →  Y 가 성립되는 애트리뷰트 X'이 존재하지 않는 경우

* 기본키에만 종속

**부분함수종속** : X’⊂ X 이고  X’ →  Y 가 성립되는 애트리뷰트 X'이 존재하는 경우

* 복합키의 일부에 종속
  * 복합키는 말그대로 기본키로 설정한게 2개이상을 칭함.
  * 즉, 2개이상의 조합으로 기본키를 설정한다는 의미

**이행함수종속** : A->B, B->C, A->C 성립시 애트리뷰트 C는 A에 이행함수종속

* (A->B->C)

**다치종속(MVD)** : A값에 대해 B값이 여러개로 결정

* 1:N

**조인종속(JD)** : A, B, ..., Z 를 R의 애트리뷰트들에 진부분집합이라 할 때 릴레이션R이 그의 프로젝션 A, B, ..., Z의 조인과 동일하면 R은 JD*(A, B, ..., Z)를 만족한다.

**모든 함수종속(FD)은 다치종속(MVD), MVD는 JD의 특별한 형태(2분해)**

**이부분은 꼭 그림과 함께 보면 이해하기 쉬우므로 그림을 참고 할 것**

<br><br>

### 제 1~5정규형

**정규형** : 정규화. 즉, 스키마 변환(S->S’)로 정규형을 만듦

* 스키마 변환의 원리 3가지 = 정규화의 원칙
  * 정보 표현의 무손실, 최소의 데이터 중복, 분리의 원칙

<br>

**제1정규형** – `원자 값`으로 분리

**제2정규형** – `부분함수종속` 제거

**제3정규형** – `이행함수종속` 제거

**보이스/코드 정규형(BCNF)** - `결정자`가 모두 `후보 키`인 경우

**제4정규형** – `다치종속`이 아예 없거나, 다치종속인데 함수종속(특징: 값 1개씩)이 아닌게 있다면 그 다치종속을 제거

**제5정규형** – `조인종속`이 그냥 없거나, 후보키를 통하지 않은 조인종속이면 제거

* **참고 : 1NF->3NF 이런식의 변화는 불가함. 순서대로 분리해야함.**

<br><br>

### 정규화 과정 (무손실 분해)

**비정규 릴레이션 ->   
[원자 값이 아닌 도메인을 분해] -> 1NF ->  
[부분 함수 종속 제거] -> 2NF ->  
[이행 함수 종속 제거] -> 3NF ->  
[결정자가 후보 키가 아닌 함수종속(FD) 제거] -> BCNF ->  
[함수 종속이 아닌 다치 종속(MVD) 제거] -> 4NF ->  
[후보 키를 통하지 않은 조인 종속(JD) 제거] -> 5NF**

* 실무에서는 진짜 많이 사용한다고 해도 BCNF까지 사용
* 4, 5NF는 이론으로만 기억할 것

<br><br>


### 역 정규형

**(보충)역정규화** – 시스템의 성능 향상, 개발 과정의 편의성, 운영의 단순화를 위해 `정규화 원칙을 의도적으로 위배`

* 정규화를 통해 분리되었던 릴레이션에서 `중복을 허용`하고 다시 통합하거나 `분할`하여 구조를 재조정하는 과정이라 할 수 있다.
* **테이블 분할(=파티셔닝)** : 수평 or 수직 분할
  * **수평 분할** : 레코드를 기준으로 테이블 분할(하나의 테이블이 가지는 레코드 개수가 많아서 사용)
  * **수직 분할** : 칼럼을 기준으로 테이블 분할(하나의 테이블이 가지는 칼럼의 개수가 많아서 사용)

* 하나의 테이블에 데이터가 너무 많으면 엑세스가 오래걸리니까 `DBMS는 알아서 수평 분할해줌`
* 다양한 경험을 필요로 하는 작업이다.

<br>

**분할의 예시**

* **갱신 위주의 칼럼 수직 분할** : 몇 개의 갱신 위주의 칼럼에 대한 작업이 나머지 조회 위주의 칼럼 이용을 방해함
  * 분리 예시 : 회원접속

* **자주 조회되는 칼럼 분할** : DBMS 매커니즘상 데이터 읽으면 메모리에 일정기간 적재. 조회 칼럼만 분리하면 성능업.
  * 분리 예시 : 회원인증

* **특정 칼럼의 크기가 아주 큰 경우 분할** : 특정한 데이터 형식에 기인하는 문제인 경우가 대부분
  * 분리 예시 : 회원사진

* **특정 칼럼에 보안을 적용해야 하는 경우의 분할** : 칼럼 자체는 권한제어가 없음. 테이블로 나눠서 권한 얻자
  * 분리 예시 : 회원등급

<br>

**중복 허용의 예시**

* 중복 테이블 유형 : 다양한 유형이 존재.(예:집계, 진행 테이블)

* 중복 칼럼 생성 – 논리 데이터 모델링 과정에서 정규화는 중복 칼럼을 최대한 제거,

* 하지만 물리 데이터 모델링 과정에서는 이러한 정규화를 어기면서 다시 중복 칼럼 생성을 수행하곤 함.

