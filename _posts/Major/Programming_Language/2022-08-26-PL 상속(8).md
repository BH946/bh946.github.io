---
title:  "PL 상속(8)"
categories : [Programming_Language]
tag : [프로그래밍언어론, 서론, 어휘구조, 구문법, 의미론, 인터프리터]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
---



Java, C++, Python에서의 상속 구현 방식, 다형 참조와 동적 바인딩, 타입 캐스팅, 추상 클래스와 가상 함수의 개념, 그리고 다중 상속의 특징에 대해 설명합니다.

<br>

## 상속

**상속 – 자식 클래스가 부모 클래스를 포함하는 집합 느낌(부모 메소드, 변수 + 자신꺼 사용하니까)**

<br>

### 1-1. Java 상속

**extends** 사용, **단일 상속**만 지원(python, C++ 은 여러개 지원!)

**super** – 부모 클래스 참조

**오버라이딩(메소드 재정의)** - 부모 클래스의 메소드를 자식 클래스가 재정의 + **서명 동일**

**오버로딩(중복정의)** - 한 클래스 내에 같은 이름이 여러 개의 메소드 + **서로 다른 서명**

* **메소드 서명(signature)** - 메소드의 매개변수 이름, 개수, 순서, 타입

<br>

#### 1-2. 다형 참조

**다형 참조** – 참조변수는 선언된 클래스의 객체뿐만 아니라 자손 클래스의 객체도 참조 가능

* **동적 바인딩(실행시간에 바인딩)** - 호출될 메소드는 참조 변수의 타입이 아닌 실행시간에 참조된 객체 타입에 결정

* **다형 참조로 동적 바인딩** 한 것은 해당 함수가 서로 있으니까 현재 참조하는 객체에 맞는 함수를 실행해준 것
  * 예시로 `emp = manager; emp.pay();` 은 오버라이딩한 manager꺼 pay()를 호출하게 됨

**참고로 이렇게 암묵적 확장만 가능하지 축소는 정보손실 때매 애초에 불허**

<br>

#### 1-2. 타입 캐스팅

**타입 캐스팅** – 부모클래스가 해당 함수 없을 때 사용**(반드시 동적 바인딩과 구분!!!)**

* 자바에서 자동 축소 아예 불허인데 **INT형만 가능**(범위 이내 가능. 예외적 상황임).
* 캐스팅(범위 이상 가능). 즉, 캐스팅은 강제로 변환!(double->int같은것). 정보손실도 상관없다는 것. 다만!!
* **클래스에선 상속에 다형참조 여야 가능**
  * 예시로 `Employee e = new Manager(); e.getbonus();`   
    getbonus() 메소드가 Manager꺼다? 그럼 부모엔 함수 없어서 사용불가.  
    이럴 때 아예 타입을 바꿔야 한다는 것!(타입 캐스팅). `(Manager) e.getbonus();` 가 올바르다.
* **타입 캐스팅이 오류인 예?** 
  * `Employee a = new Employee(); Manager b = (Manager) a;`  
    다형 참조가 아니기 때문에 캐스팅 불가.

**즉, 다형참조 후에 캐스팅해야 캐스팅 가능, 다형참조 아니면 캐스팅 불가**

<br>

#### 1-3. 추상 클래스

**추상 클래스** – 덜 구현된 클래스. 따라서 실체화될 수 없다(객체 생성X)

자식클래스가 부모 클래스의 해당 추상메소드를 구현하지 않으면 자신도 추상 클래스가됨(강제 오버라이딩 시키는구조라 판단)

* `abstract class 클래스이름 { abstract 리턴타입 메소드이름(매개변수선언); // 본체가 없다 }`
  * 추상 메소드는 final, static으로 선언X
  * 추상 메소드는 코드처럼 본체가 없다

<br>

추상클래스가 Worker였고, pay()메소드가 추상메소드였다면? 

* 자식 클래스인 Employee와 Parttimer또한 메소드 오버라이딩 했을 것이다. 
* 그럼 `Worker work = new Employee() 나 Parttimer()` 로 work가 원하는 pay()메소드 사용가능

* **추상 클래스를 쓰면 이렇게 공통된 하나의 Worker로 표현이 가능. 이것이 주로 추상을 사용하는 이유!**

<br>

### 2-1. C++ 상속

**명칭 구분**

* C++ : 데이터 멤버, 멤버함수

* Java : 인스턴스 변수, 메소드

<br>

**C++의 가상 함수** – virtual로 선언된 함수로 자식클래스에서 재정의 가능한 함수(Java 메소드는 virtual!!)

* 가상 함수 호출 – 객체 타입에 따라 동적 바인딩

**C++의 순수 가상 함수** – 자식클래스에서 정의되는 함수(Java의 추상 메소드). 본체가 정의 안된 함수로 암기

* 가상 함수가 아니라면 정적 바인딩을 한다.(컴파일시간. 타입선언)
  * 정적 바인딩 장점은 실행 효율. 그래서 C++은 자바보다 기본적으로 빠름.

<br>

유효범위 해결 연산자 – Student::sleep() 혹은 Worker::sleep()

* 다중상속의 죽음의 다이아몬드 문제를 해결

<br>

### 3-1. Python 상속

C++의 virtual선언 같은 것이 필요없고, 자바처럼 바로 재정의(오버라이딩)가능

다중상속의 죽음의 다이아몬드 문제없음

* 다중상속의 메소드를 메소드 탐색 순서대로 확인하기 때문

<br>
