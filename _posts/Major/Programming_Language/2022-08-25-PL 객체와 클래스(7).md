---
title:  "PL 객체와 클래스(7)"
categories : [Programming_Language]
tag : [프로그래밍언어론, 서론, 어휘구조, 구문법, 의미론, 인터프리터]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
---



## 객체지향 언어 역사

**Simula-67, Smalltalk, C++, Java**

* C++, JAVA도 Simula-67의 영향을 많이 받음
* C++에서 가상함수란 동적 바인딩. 즉 실행시간에 바인딩.(자바도 마찬가지)
  * 즉, C++의 virtual 함수와 자바의 일반 함수는 동적 바인딩으로 할당한다.
* 참고로 GUI란 그래픽 유저 인터페이스



**Objective-C/Swift, C#, Python**

* Python도 인터프리터 언어기 때문에 `플랫폼 독립적`이며 `동적 타이핑`을 지원



**`(C)프로그램`은 `데이터`(변수, 구조체/배열 등) + `명령어`(배정문, 조건문/반복문, 함수)로 구성**

**`객체지향프로그램`은 데이터(구조체)+명령어(함수)가 `객체`(클래스)고, 객체들과의 `상호작용`으로 구성**

* `객체(instance)` – 속성(데이터), 행동(연산)

* `클래스` - 객체의 정의 or 타입

* `프로그램` - 클래스들의 집합

* `프로그램 실행` - 서로 상호작용하는 객체들의 집합





### 캡슐화

**추상 자료형** - 캡슐화하여 정의한 자료형

* 외부에서 접근X
* 내부에서 메소드로 `필드변수` 접근O



**클래스** - 캡슐화 + 더 많은 기능 제공

* 참고로 파이썬의 self는 Java의 this이다. 
* 예로 `self.name` 으로 바로 사용가능



**접근 지정자**

* Java – public, private, package, protected

* Python – 밑줄x(public), __로 시작(private), _로 시작(protected)





### 정적 변수 및 정적 메소드 - static

**실체 변수(객체 변수)** – 각 객체마다 기억공간이 할당됨(`인스턴스 내`에 변수)

* 자바 - 선언해서 바로 사용

* 파이썬 - 선언하지 않고 바로 사용(타입 지정을 안하다보니)



**정적 변수(=클래스 변수)**

* 자바 - static으로 선언된 변수(`클래스 내`에 기억공간 생성)
* 파이썬 - 그냥 바로 초기화가 됨. 대신 사용은 자바처럼 클래스명.변수명으로 동일



**정적 메소드(=클래스 메소드)** – static으로 선언된 메소드(`객체 생성 X` => 따라서 실체 변수 사용 못함)

**전역 변수(=객체변수 + 클래스변수)** - `어디서든 호출 가능`. 즉, 클래스 내에서 or 객체들 내에서 사용가능한 변수

* 자바 - 전역에서 사용 가능

* 파이썬 - 전역에서 사용 가능(다만, global 선언어 필요할 때가 있음)

  * global 선언은 다른 클래스에서도 전역으로 사용하게 해줌. 근데 그냥 해도 사용됨.

  * 다만 함수에선 지역변수로 자동 생성(실체변수)되므로 global 선언 꼭 해줘야 전역 변수를 바인딩함.

<br>

## Java 클래스

**중요) 클래스에서 타입 캐스팅은 부모-자식 관계여야 가능**

class 클래스 이름 {...} 내부에 3가지를 클래스 멤버라 칭한다.

* 3가지 : 필드 변수 선언, 생성자 선언, 메소드 선언



**객체 참조 변수 선언** – 객체 생성된 것 아님(그러나 C++은 생성. 정적 바인딩)

**객체 생성** – new 연산자로 객체 생성된 것(동적 바인딩)

* 스택에 acc1(즉, 변수명), 힙에 객체(instance)할당 => acc1이 힙에 객체를 가리킴

* 스택에 acc1이 제거되면? 
  * 힙에 객체는 GC가 제거해주고, C는 free()로 직접 반환. 자바는 C처럼 접근 불가





### 제네릭

**제네릭 프로그래밍 – `매개변수 다형성`**

**제네릭 클래스** – `타입 매개변수(type parameter)`를 받는 클래스

* `ArrayList<Integer>...`

* `public class Box<T> { }`



**제네릭 메소드** – `타입 매개변수(type parameter)`를 받는 메소드

* `public static <T> Box<T> boxing(T t) {...}` (참고로 `Box<T>`는 실제 클래스 타입이다!



**호출 방법** - 클래스는 뒤에, 메소드는 앞에 `<>`

* `Box<String> box1 = TestBox.<String>boxing(“test”);`   
  참고로 TestBox클래스의 메소드인 boxing() 을 호출 한 것

<br>

## python 클래스

`class 클래스명:` 으로 클래스를 선언한다.

* **생성자** : `def __init__(self, 매개변수):` 
* **소멸자** : `def __del__(self, 매개변수):`

<br>

## C++ 객체 및 클래스

**특징은 this->name이다.** 

* this가 자바나 파이썬도 주소지만(당연히 모든 변수는 주소) 객체를 저장한 메모리 주소이고, 

* C는 그 객체 저장한 메모리 주소를 저장한 메모리를 가리키는 주소라 차이가 있는 것이다(사실 햇갈림..)



**객체 변수 접근**은 `this->balance 와 balance` 둘다 가능

**객체 생성 방식 2가지**(자바랑 구분, 자바는 애초에 new로 생성해도 `.`으로 접근함)

1. **클래스 타입으로 변수를 선언(정적) - 스택**
   * `int a=0;` - 스택
   * `a;` - 주소가 아닌 **값**
   * 클래스 타입으로 선언한 acc1도 주소가 아닌 **값**으로 접근
   * 따라서 `acc1.메소드`로 사용가능

2. **new 연산자를 이용한 동적 객체 생성 - 힙**
   * `(*p).메소드명`  또는
   * `p->메소드명` 으로 접근이 가능
   * new를 통해 주소를 저장해서 동적으로 객체 생성하기 때문





### 템플릿 – 제네릭 프로그래밍

**템플릿 – `매개변수 다형성`**

**템플릿 클래스** – `template <typename 변수이름>` 을 class 선언전에 추가, type자리엔 전부 T

**템플릿 함수** - `template <typename 변수이름>` 을 함수 선언전에 추가, type자리엔 전부 T

**자바와 차이점**

* 정의 표기법이 좀 다르고, 
* 실행 때 자바와 다르게 클래스, 함수 둘다 `예로 <int>`가 뒤에 들어감
  * `sum<int>(1,2);` 와 `Box<string> b(“hello”);`

​    
