---
title:  "PL 객체와 클래스(7)"
categories : [Programming_Language]
tag : [프로그래밍언어론, 서론, 어휘구조, 구문법, 의미론, 인터프리터]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
---



객체지향 프로그래밍 언어의 역사와 핵심 개념을 설명합니다. Simula-67부터 Java, Python까지 주요 객체지향 언어의 발전 과정, 캡슐화 원리, 정적/실체 변수와 메소드의 차이, 그리고 Java, Python, C++에서의 클래스 구현 방식과 제네릭/템플릿 프로그래밍 특징을 비교하여 다루고 있습니다.

<br>

# 객체지향 언어 역사

**Simula-67, Smalltalk, C++, Java**

* C++, JAVA도 Simula-67의 영향을 많이 받음
* C++에서 가상함수란 동적 바인딩. 즉 실행시간에 바인딩.(자바도 마찬가지)
  * 즉, C++의 virtual 함수와 자바의 일반 함수는 동적 바인딩으로 할당한다.
* 참고로 GUI란 그래픽 유저 인터페이스

<br>

**Objective-C/Swift, C#, Python**

* Python도 인터프리터 언어기 때문에 `플랫폼 독립적`이며 `동적 타이핑`을 지원

<br>

**`(C)프로그램`은 `데이터`(변수, 구조체/배열 등) + `명령어`(배정문, 조건문/반복문, 함수)로 구성**

**`객체지향프로그램`은 데이터(구조체)+명령어(함수)가 `객체`(클래스)고, 객체들과의 `상호작용`으로 구성**

* `객체(instance)` – 속성(데이터), 행동(연산)

* `클래스` - 객체의 정의 or 타입

* `프로그램` - 클래스들의 집합

* `프로그램 실행` - 서로 상호작용하는 객체들의 집합

<br><br>

## 캡슐화

**추상 자료형** - 캡슐화하여 정의한 자료형

* 외부에서 접근X
* 내부에서 메소드로 `필드변수` 접근O

<br>

**클래스** - 캡슐화 + 더 많은 기능 제공

* 참고로 파이썬의 self는 Java의 this이다. 
* 예로 `self.name` 으로 바로 사용가능

<br>

**접근 지정자**

* Java – public, private, package, protected

* Python – 밑줄x(public), __로 시작(private), _로 시작(protected)

<br><br>

## 정적 변수 및 정적 메소드 - static

**변수?**

* **실체 변수(=객체 변수)** – 각 객체마다 기억공간이 할당됨(`인스턴스 내`에 변수)

  * 자바 - 선언해서 바로 사용


  * 파이썬 - 선언하지 않고 바로 사용(타입 지정을 안하다보니)


* **정적 변수(=클래스 변수)**

  * 자바 - static으로 선언된 변수(`클래스 내`에 기억공간 생성)

  * 파이썬 - 그냥 바로 초기화가 됨. 대신 사용은 자바처럼 `클래스명.변수명` 으로 동일

* **전역 변수(=객체변수 + 클래스변수)** - `어디서든 호출 가능`. 즉, 클래스 내에서 or 객체들 내에서 사용가능한 변수

  * 자바 - 전역에서 사용 가능

  * 파이썬 - 전역에서 사용 가능(다만, **global 선언**이 필요할 때가 있음)

    * global 선언은 **다른 클래스**에서도 전역으로 사용하게 해줌. 근데 **그냥 해도 사용**됨.

    * 다만 **함수에선** 지역변수로 자동 생성(실체변수)되므로 **global 선언 꼭 해**줘야 전역 변수를 바인딩함.

<br>

**메소드?**

* **실체 메소드(=객체 메소드)** - `객체 생성 후` 사용가능, 해당 인스턴스내 메소드

* **정적 메소드(=클래스 메소드)** – static으로 선언된 메소드(`객체 생성 X` => 따라서 실체 변수 사용 못함)

<br><br>

# 클래스

## 1-1. Java 클래스

**중요) 클래스에서 타입 캐스팅은 부모-자식 관계여야 가능**

class 클래스 이름 {...} 내부에 3가지를 **"클래스 멤버"**라 칭한다.

* 3가지 : 필드 **변수** 선언, **생성자** 선언, **메소드** 선언

<br>

**객체 참조 변수 선언** – 객체 생성(동적할당)된 것 아님(그러나 C++은 생성. 정적 바인딩)

**객체 생성** – new 연산자로 객체 생성된 것(동적 바인딩)

* 스택에 acc1(즉, 변수명), 힙에 객체(instance)할당 => acc1이 힙에 객체를 가리킴

* 스택에 acc1이 제거되면? 
  * 힙에 객체는 자바의 경우 GC가 제거해주고, C언어는 free()로 직접 반환
  * 자바는 C처럼 메모리에 직접 접근 불가하기 때문

<br><br>

### 1-2. 제네릭

**제네릭 프로그래밍 – `매개변수 다형성`**

* **제네릭 클래스** – `타입 매개변수(type parameter)`를 받는 클래스

  * `ArrayList<Integer>...`


  * `public class Box<T> { }`

* **제네릭 메소드** – `타입 매개변수(type parameter)`를 받는 메소드

  * `public static <T> Box<T> boxing(T t) {...}` (참고로 `Box<T>`는 실제 클래스 타입이다!

* **호출 방법** - 클래스는 뒤에, 메소드는 앞에 `<>`

  * `Box<String> box1 = TestBox.<String>boxing(“test”);`   
    참고로 TestBox클래스의 메소드인 boxing() 을 호출 한 것


<br><br>

## 2-1. python 클래스

`class 클래스명:` 으로 클래스를 선언한다.

* **생성자** : `def __init__(self, 매개변수):` 
* **소멸자** : `def __del__(self, 매개변수):`

<br><br>

## 3-1. C++ 객체 및 클래스

**특징은 `this->name`이다.** 

* this가 자바나 파이썬도 주소지만(당연히 모든 변수는 주소) 객체를 저장한 메모리 주소이고, 

* C는 그 객체 저장한 메모리 주소를 저장한 메모리를 가리키는 주소라 차이가 있는 것이다(

<br>

**객체 변수 접근**은 `this->balance 와 balance` 둘다 가능

**객체 생성 방식 2가지**(자바랑 구분, 자바는 애초에 new로 생성해도 `.`으로 접근함)

1. **클래스 타입으로 변수를 선언(정적) - 스택**
   * `int a=0;` - 스택
   * `a;` - 주소가 아닌 **값**
   * 클래스 타입으로 선언한 acc1도 주소가 아닌 **값**으로 접근
   * 따라서 `acc1.메소드`로 사용가능
2. **new 연산자를 이용한 동적 객체 생성 - 힙**
   * `(*p).메소드명`  또는
   * `p->메소드명` 으로 접근이 가능
   * new를 통해 주소를 저장해서 동적으로 객체 생성하기 때문

<br>

### 3-2. 템플릿 – 제네릭 프로그래밍

**템플릿 – `매개변수 다형성`**

**템플릿 클래스** – `template <typename 변수이름>` 을 class 선언전에 추가, type자리엔 전부 T

**템플릿 함수** - `template <typename 변수이름>` 을 함수 선언전에 추가, type자리엔 전부 T

**자바와 차이점**

* 정의 표기법이 좀 다르고, 
* 실행 때 자바와 다르게 클래스, 함수 둘다 `예로 <int>`가 뒤에 들어감
  * `sum<int>(1,2);` 와 `Box<string> b(“hello”);`

