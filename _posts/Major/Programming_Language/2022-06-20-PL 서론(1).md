---
title:  "PL 서론(1)"
categories : [Programming_Language]
tag : [프로그래밍언어론, 서론, 어휘구조, 구문법, 의미론, 인터프리터]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
---



프로그래밍 언어의 기본 개념과 구조를 설명합니다. 어휘구조, 구문법, 의미론과 같은 언어 이론의 기초부터 데이터/제어 추상화, 다양한 자료형 시스템, 자동 형변환 원리, 그리고 명령형, 함수형, 논리형, 객체지향 프로그래밍 패러다임의 특징을 비교하여 다루고 있습니다.

<br>

# PL(Programming Language)란?

> 정리 하고 싶은 부분만 정리한 것이기 때문에 내용이 탄탄하지는 않다는점 참고

<br>

## PL?

* **계산 과정을 기계, 사람이 읽을 수 있게 기술한 표기법**
* **종류** : 절차형(명령형) 언어, 함수형 언어, 논리 언어, 객체-지향 언어 등등  
  절차형(명령형)은 기계 중점. 즉, C같은 언어이다.
* **주요 언어 이론** : 구문법(토큰->AST), 의미론(AST->해석), 타입 시스템(타입검사)
* **토큰** : 문법의 터미널 심볼 단위, **터미널** : 끝을 의미, **심볼** : Symbol, **AST** : 추상 구문 트리

**어휘구조** : 토큰, **어휘분석** : 토큰으로 나누기  
**구문법** : 문법을 이용한 기술, **구문분석** : 토큰들을 분석 및 AST로 나타냄  
**의미론** : 문장/프로그램 의미 정하는 것, **의미분석** : AST를 인터프리터로 실행 해석 출력  
**타입 시스템** : 타입 관련 여러가지..  

**언어 구현** : 입력 프로그램 -> **구문법(Syntax)** -> **의미론(Semantics)** -> 인터프리터/컴파일  
**컴파일러** : 의미 분석후 코드 생성 -> 목적 프로그램, 파일 생성   
**인터프리터** : 의미 분석후 해석(실행)

<br><br>

## 추상화 - 데이터, 제어(명령어), 추상자료형(ADT)

* **컴퓨터의 데이터, 명령어, 연산 등을 추상화**

**데이터 추상화**  
=> 기본 추상화 : 기본 데이터 관련한 요약(예: 변수(x 등), 자료형(int 등))  
=> 구조적 추상화 : 관련된 여러 값/변수들의 모음을 요약(예: 배열(같은타입), **레코드(구조체)**(다른타입))

**제어(명령어) 추상화**  
=> 기본 추상화 : 몇 개의 기계어 명령어들을 하나의 문장으로 요약(예: 대입문, goto문)  
=> 구조적 추상화 : 테스트 내의 중첩된 기계어 명령어들을 하나의 문장으로 요약(예: if,switch,for,while 등)  
=> 프로시저(함수, 메소드) : 선언과 호출

**추상 자료형(데이터 + 관련 연산)**  
=> 데이터와 관련된 연산들 캡슐화하여 정의한 자료형(예: Modula-2모듈, Ada패키지, (C++,Java)등의 클래스)

<br><br>

## 자료형

* **값의 집합 + 연산의 집합**
* **타입 구성자** : 기본 자료형으로부터 더 복잡한 자료형(**복합 타입**)을 구성하는 방법    
  => 배열(같은타입), 리스트(다른타입도 허용), 레코드(예: C의 struct), 공용체(Union),  
  포인터 타입(예: C의 포인터. 위치(주소)를 값으로 사용하는 특징), 사용자-정의 타입(예: 사용자가 만든 class)

**int x;** 에서 이 자료형의 의미 : 값 + 연산을 의미  
=> 값 : 그 타입의 변수가 가질 수 있는 값들의 집합. x ∈ Integer  
=> 연산 : 추가로 그 값에 적용 가능한 연산들의 모음(데이터 타입에 맞게 연산하는지 체크)

<br>

### 1. C의 자료형(기본형, 파생형으로 나뉨)

* **정수형**은 아스키코드 값이 저장. **무치형**은 값이 없다는 것. **아스키코드**(1byte=8bit)는 문자만 표현
* 구조체는 멤버변수가 **각각의** 메모리 공간을 할당받고 있음
* **공용체**는 같은 메모리공간을 모든 변수가 공유하는 형태
* C에선 **boolean**형 타입 없고, 0이면 false, 1이면 true 이런식임

<br>

### 2. Java의 자료형(기본형, 참조형으로 나뉨)

* **유니코드**는 더 커서 한글도 표현. **boolean**형 타입도 존재
* **참조 자료형**을 보면 C의 포인터와 유사해 보이지만 포인터는 연산이 가능해서 메모리에서 직접 값을 변경할 수 있는반면 참조 자료형은 불가. 그래서 메모리 해제도 GC가 동작(가비지 컬렉션)

<br><br>

## 자동 형변환

**자동으로 형 변환하는 묵시적 형 변환**

* **확장 변환(상향 변환)** : Java에서 자동 형변환은 대부분 확장 변환(예: double y=99; // 99.0)
  * 그러나 반대의 경우는 정보 손실이 일어날일이 없음. 확장 변환(y=x)
* **축소 변환** : 확장 변환의 반대
  * 큰타입이 작은타입으로 바뀌려는건 정보 손실. 축소 변환(x=y)
* **대입 변환** : `대입문`도 확장 변환인 경우에만 자동 수행(축소 변환은 X)
  * 그런데 예외적으로 int 상수에 대해서만 **자동 축소 변환가능**
* 예시
  * byte b = 123; // 축소 변환
  * short s = 456; // 축소 변환
  * int i = s; // 확장 변환 (값을 몰라도 타입은 아니까 바로 확장 변환)
  * byte b2 = 456; // 오류 (byte 범위 밖)
  * short s2 = i; // 오류 (타입은 알아도 현재 값은 모름)
  * 컴파일할 때 변수의 TypeO, 값X(모름)
* **C는 확장, 축소 둘다 허용**
* **자바는 확장, 손실없는 축소 까지 허용**



**참고로 캐스팅의 경우?**

* C, 자바 둘다 문제없음. 즉, 명시적이지 자동 묵시적 형변환이 아님

<br><br>

# 프로그래밍 패러다임

## 명령형(절차) 프로그래밍(C,Pascal,Ada,Python)  

* **기계형 명령어들을 좀 더 다루기 쉽게 해준다**  
  **즉, 사람보다는 컴퓨터모델을 기반으로 만들어진 언어이다.**

**폰노이만 모델** 영향받음  
=> 폰 노이만 모델 컴퓨터(메모리에 적재 방식, 주메모리(=명령어+데이터), CPU)  
=> 순차적으로 코드 실행, 프로그램 내장 방식 

**순차적** 코드 구성   
**메모리(변수)** 사용  
**대입문**(배정문=변수의 값을 변경) 사용   

<br><br>

## 함수형 프로그래밍(Lisp,Scheme,ML,Haskell)

**수학 함수** 형태   
**메모리 개념 없음**  
=> **변수 및 대입문**(배정문. 메모리 할당) **없음**    

**반복문 없음**   
=> **대안 : 리커전 반복**

<br><br>

## 논리 프로그래밍(Prolog)

**선언적 프로그래밍**(선언적은 과정은 필요없고 특징만 생각)  
**정형(술어) 논리**를 기반으로 한다  
문제에 대한 **사실/규칙**을 표현하는 논리 문장(**증명**)    
**메모리 개념 없음**  
=> **변수**는 부분 결과 값에 대한 **이름일 뿐**

<br><br>

## 객체지향 프로그래밍(종류 매우 많음) - 객체 개념

* **(C)프로그램**은 **데이터**(변수, 구조체/배열 등) + **명령어**(배정문, 조건문/반복문, 함수)로 구성

* **객체지향프로그램**은 **데이터**(구조체)+**명령어**(함수)로 구성

**클래스**는 객체의 **정의** or **타입**   
**객체(instance=인스턴스)** 는 속성(데이터)+행동(연산)이며, 클래스로 생성   
**프로그램**은 클래스들의 집합  
**프로그램 실행**은 서로 상호작용하는 객체들의 집합



