---
title:  "[java,ë°±ì¤€12100]2048 Easy - ë¸Œë£¨íŠ¸í¬ìŠ¤(BFS, DFS)ë¡œ ìµœëŒ€ê°’ ì°¾ê¸°"
categories : [BaekjoonTest]
tag : [ë°±ì¤€, ì•Œê³ ë¦¬ì¦˜, DFS, ì‹œë®¬ë ˆì´ì…˜, êµ¬í˜„, ì¤‘ë³µìˆœì—´]
toc: true
toc_sticky: true
author_profile: false
sidebar:
   nav: "docs"
typora-root-url: ../../..
---



**BFSë‚˜ DFS(+ë°±íŠ¸ë˜í‚¹)ë¡œ ì‹œë®¬ë ˆì´ì…˜ì„ í™œìš©í•˜ì—¬ 2048 ê²Œì„ì„ ìµœëŒ€ 5ë²ˆ ì§„í–‰í–ˆì„ ë•Œ ì–»ì„ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ë¸”ë¡ ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.**

**[2048 Easy(ë°±ì¤€12100)](https://www.acmicpc.net/problem/12100)**

**2048 ì´ë¼ëŠ” ê²Œì„ì„ ì´** [**ë§í¬ì—ì„œ**](https://play2048.co/) **í”Œë ˆì´í•´ë³¼ ìˆ˜ ìˆë‹¤.**

<br>

**í—·ê°ˆë¦¬ëŠ” ì˜ˆì‹œë¥¼ ì‹œê°í™” í•´ë³´ì**

```text
N=3
2 2 4    2 2 4    0 4 4
0 0 0 -> 0 0 0 -> 0 0 0
0 0 0    0 0 0    0 0 0
(ì´ˆê¸°)   (ì˜¤ë¥¸ìª½)  (ì˜¤ë¥¸ìª½)
ì¦‰, ì˜¤ë¥¸ìª½ ë•Œ 0 0 8ì´ ëœë‹¤ê³  í—·ê°ˆë¦¬ì§€ ë§ì.

2 2 4    4 0 4    4 4 0
0 0 0 -> 0 0 0 -> 0 0 0
0 0 0    0 0 0    0 0 0
(ì´ˆê¸°)   (ì™¼ìª½)    (ì™¼ìª½)
ì¦‰, ì™¼ìª½ ë•Œ 8 0 0ì´ ëœë‹¤ê³  í—·ê°ˆë¦¬ì§€ ë§ì.
```

<br>

<br>

## í’€ì´

**êµ¬í˜„ ì‹œ ì£¼ì˜ì‚¬í•­**

ğŸ’¡ **<span style="color:#ff9300">DFSë¡œ 4ë°©í–¥ ì´ë™ì„ ì¤‘ë³µìˆœì—´ì²˜ëŸ¼ íƒìƒ‰+ìƒíƒœê¸°ë¡(ë°±íŠ¸ë˜í‚¹)+ê° ë°©í–¥ìœ¼ë¡œ ì´ë™ ì‹œë®¬ë ˆì´ì…˜</span>**ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•œë‹¤.  
=> ì›€ì§ì¼ ë•Œ ë§ˆë‹¤ ë””ë²„ê¹… ì¶”ì²œ!! (ë°°ì—´ ì¶œë ¥í•´ë³´ì•„ë¼)

ğŸ’¡ **<span style="color:#ff9300">BFSëŠ” ìƒíƒœê¸°ë¡(ë°±íŠ¸ë˜í‚¹) ì—†ì´ íì— ê¸°ë¡í•˜ëŠ” ì°¨ì´</span>**ê°€ ì „ë¶€ì´ë‹¤. 

ğŸ’¡ ìµœëŒ€ 5ë²ˆì´ ì „ë¶€ì´ë¯€ë¡œ **<span style="color:#ff9300">ë³µì¡ë„ëŠ” ì‹ ê²½ ì“¸ í•„ìš” ì—†ë‹¤.</span>**

<br>

**í•µì‹¬ êµ¬í˜„ ì‚¬í•­**

- DFSë‚˜ BFSë¥¼ í†µí•œ **ìµœëŒ€ 5ë²ˆì˜ ì´ë™ íƒìƒ‰!**
- **ì œì¼ ì¤‘ìš”í•œ êµ¬í˜„ì‚¬í•­**
  1. ì´ë™ ë°©í–¥ì˜ ë¸”ë¡ ìš°ì„ ìˆœìœ„ ì²˜ë¦¬
  2. ë¸”ë¡ í•©ì¹˜ê¸° ì²˜ë¦¬ (ì´ë¯¸ í•©ì¹œê±´ í•©ì¹˜ì§€ ì•Šê¸°)
- ê° ìƒíƒœì—ì„œ **ìµœëŒ€ê°’ ê°±ì‹ !**

<br>

**ë¸”ë¡ ì´ë™ ì²˜ë¦¬(ë°©í–¥,ì¢Œí‘œ ì„¤ì •)**

```java
static void move(int dir, Pair[][] board) {
    if (dir == 0) { // '->'
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                moveElement(i, N - 1 - j, board, dir);
            }
        }
    }else if (dir == 1) { // 'ì•„ë˜'
    // ...
}
```

<br>

**ë¸”ë¡ ì´ë™ ì²˜ë¦¬(while)**

1. `nx<0 || ny<0 || nx>N-1 || ny>N-1` : **ë²”ìœ„ ì´ˆê³¼** ì¼ ë•Œ ì²˜ë¦¬ -> ë
2. `board[nx][ny].val == 0)` : **ë¹ˆ ê³µê°„** ì¼ ë•Œ ì²˜ë¦¬ -> ë¸”ë¡ ì´ë™í•˜ë ¤ê³ 
3. `board[nx][ny].val == board[x][y].val && !board[nx][ny].sum` : **ìˆ«ìê°€ ê°™ì€ ë¸”ë¡+ì´ë¯¸ í•©ì¹œ ì  ìˆëŠ” ë¸”ë¡** ì¼ ë•Œ ì²˜ë¦¬ -> ë¸”ë¡ í•©ì¹˜ë ¤ê³ 
4. `board[nxt] != board[nxt-1]` : **ìˆ«ìê°€ ë‹¤ë¥¸ ë¸”ë¡** ì¼ ë•Œ ì²˜ë¦¬ -> ë

```java
static void moveElement(int x, int y, Pair[][] board, int dir) {
    int nx = x, ny = y;
    while (true) {
        nx += dx[dir];
        ny += dy[dir];
        if (nx < 0 || ny < 0 || nx >= N || ny >= N) break;
        // ì´ë™ ë° í•©ì¹˜ê¸° ì²˜ë¦¬
        // ...
        x=nx;
	    y=ny; //ì´ì „ ê¸°ë¡
    }
}
```

<br>

<br>

## ì „ì²´ ì½”ë“œ - BFS, DFS ë‘˜ ë‹¤

### DFS ë°©ì‹1

**ì´ë¯¸ í•©ì¹œ ë¸”ë¡ì¸ì§€ ì²´í¬: Pair ì‚¬ìš©í•œ í’€ì´**

```java
public class BOJ_2048Easy_12100 {
  static int N;
  static Pair[][] map;
  static int result;
  static int[] dx = {0, 1, 0, -1};
  static int[] dy = {1, 0, -1, 0};

  //ë°©í–¥ ëê°€ì§€ ì´ë™ í•¨ìˆ˜(while)
  static void moveElement(int x, int y, Pair[][] board, int dir) {
    int nx = x;
    int ny = y;
    while (true) {
      nx = dx[dir]+nx;
      ny = dy[dir]+ny;
      if(nx<0 || ny<0 || nx>N-1 || ny>N-1) break;
      if (board[nx][ny].val == 0) {
        board[nx][ny].val=board[x][y].val;
        board[nx][ny].sum=board[x][y].sum;
        board[x][y].val=0; board[x][y].sum=false;
      } else if (board[nx][ny].val == board[x][y].val && !board[nx][ny].sum) {
        board[nx][ny].val += board[x][y].val;
        board[nx][ny].sum = true;
        board[x][y].val=0; board[x][y].sum=false;
        break;
      } else { //board[nxt] != board[nxt-1]
        break;
      }
      x=nx;
      y=ny; //ì´ì „ ê¸°ë¡
    }
  }
  //ë°©í–¥ ëê¹Œì§€ ì´ë™ í•¨ìˆ˜(ì¢Œí‘œì„¤ì •)
  static void move(int dir, Pair[][] board) {
    if (dir == 0) { // '->'
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          moveElement(i, N - 1 - j, board, dir);
        }
      }
    }else if (dir == 1) { // 'ì•„ë˜'
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          moveElement(N - 1 - j, i, board, dir);
        }
      }
    }else if (dir == 0) { // '<-'
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          moveElement(i, j, board, dir);
        }
      }
    }else { // 'ìœ„'
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          moveElement(j, i, board, dir);
        }
      }
    }
  }

  static void dfs(int depth, Pair[][] board) {
    //base condition
    if (depth == 5) {
      int maxVal=0; //ì œì¼ í° ê°’
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          maxVal = Math.max(maxVal, board[i][j].val);
        }
      }
      result = Math.max(result, maxVal);
      return;
    }
    //recursion
    for (int i = 0; i < 4; i++) {
      Pair[][] copy = new Pair[N + 1][N + 1]; //í•­ìƒ ë³µì œë³¸ì„ ë„˜ê²¨ì•¼ ê·¸ ë‹¹ì‹œì˜ ìƒíƒœê°’ì„ ìœ ì§€í•  ìˆ˜ ìˆë‹¤.
      for (int j = 0; j < N; j++) {
        for (int k = 0; k < N; k++) {
          copy[j][k]=new Pair(board[j][k].val, false); //false ë¡œ init
        }
      } //ê°„ë‹¨í•œ ë³µì œë©´ clone ë©”ì†Œë“œ ì‚¬ìš© ì¶”ì²œ
      move(i, copy); //ê²Œì„ì‹œì‘
//      printAll(depth+1, copy, i); //debug
      dfs(depth + 1, copy);
    }
  }

  private static void printAll(int depth, Pair[][] copy, int dir) {
    System.out.println("depth:"+ depth);
    System.out.println("dir:"+ dir);
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        System.out.print(copy[i][j]+",");
      }
      System.out.println();
    }
    System.out.println();
  }

  public static void main(String[] args) throws IOException {
    //input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    N = Integer.parseInt(br.readLine());
    map = new Pair[N+1][N+1];
    for (int i = 0; i < N; i++) {
      StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
      for (int j = 0; j < N; j++) {
        map[i][j] = new Pair(Integer.parseInt(stk.nextToken()), false);
      }
    }
    //run
    dfs(0, map);
    //output
    System.out.println(result);
  }

  static class Pair {
    int val; boolean sum;

    public Pair(int val, boolean sum) {
      this.val=val; this.sum=sum;
    }

    @Override
    public String toString() {
      return "Pair{" +
          "val=" + val +
          ", sum=" + sum +
          '}';
    }
  }

}
/*
3
2 2 4
0 0 0
0 0 0

3
2 0 0
2 2 0
2 0 0

4
2 4 8 2
2 4 0 0
2 0 0 0
2 0 2 0
 */
```

<br><br>

### DFS ë°©ì‹2

**ì´ë¯¸ í•©ì¹œ ë¸”ë¡ì¸ì§€ ì²´í¬: flagMap\[][] ì‚¬ìš©í•œ í’€ì´**

```java
import java.io.*;
import java.util.*;
public class ì´ê³µì‚¬íŒ”_12100 {
  static final int MAX_COUNT = 5;
  static final int[] dx = {0, 1, 0, -1};
  static final int[] dy = {1, 0, -1, 0};
  static int N, result;
  static int[][] inArr;

  public static void moveElement(int x, int y, int dir, int[][] flagMap) {
    int nx = x; int ny = y;
    int init = inArr[x][y]; //ì´ˆê¸°ê°’
    while (true) {
      nx += dx[dir];
      ny += dy[dir];
      //base condition -> ëª» ì›€ì§ì¼ ë•Œ (ë²”ìœ„ ì´ˆê³¼, ìˆ«ì ë‹¤ë¥¸ ë¸”ë¡, ì´ë¯¸ í•©ì¹œ ë¸”ë¡)
      if(nx<0 || ny<0 || nx>=N || ny>=N) break;
      if(inArr[nx][ny] != 0 && init != inArr[nx][ny]) break;
      if(inArr[nx][ny] != 0 && init == inArr[nx][ny]
          && (flagMap[nx][ny] == 1 || flagMap[x][y] == 1)) break; //flagëŠ” ì´ë™í•˜ëŠ” ë¸”ë¡ê³¼ ì´ë™í•  ìœ„ì¹˜ì˜ ë¸”ë¡ ë‘˜ë‹¤ ì²´í¬í•´ì•¼ í•œë‹¤.
      //while - update
      if (inArr[nx][ny] == 0) {
        inArr[nx][ny] = init;
      } else {
        //ì—¬ê¸°ëŠ” ìˆ«ì í•©ì¹˜ëŠ” ë¶„ê¸°ë°–ì— ì—†ìŒ -> ë‚˜ë¨¸ì§€ ë¶„ê¸°ëŠ” ìœ„ì—ì„œ ì´ë¯¸ ì²˜ë¦¬
        inArr[nx][ny] = init*2;
        init = init*2; //init ë„ update
        flagMap[nx][ny] = 1;
      }
      inArr[x][y] = 0;
      x = nx; y = ny;
    }
  }

  public static void move(int dir, int debug) {
    // êµ¬í˜„ - N*N ê° ì›ì†Œë§ˆë‹¤ ì ìš© + ë°©í–¥ë³„ êµ¬ë¶„(ë°©í–¥ìª½ ì›ì†Œë¶€í„° ì ìš©) + ì´ë™ì€ ëê¹Œì§€(ìš”ì†Œë‹¨ìœ„ while)
    int[][] flagMap = new int[N + 1][N + 1]; //N ì‘ìœ¼ë‹ˆ ë§¤ë²ˆ ì¬í• ë‹¹ (ì´ˆê¸°ê°’ 0)
    for (int i = 0; i < N; i++) {
      if (dir == 0) { //ì˜¤ë¥¸ìª½ -> ë°©í–¥ìª½ ì›ì†Œë¶€í„° ì ìš© ì¤‘ìš”
        for (int j = N - 1; j >= 0; j--) {
          moveElement(i, j, dir, flagMap); // ëê¹Œì§€ ì´ë™
        }
      } else if (dir == 1) { //ì•„ë˜ìª½
        for (int j = N - 1; j >= 0; j--) {
          moveElement(j, i, dir, flagMap);
        }
      } else if (dir == 2) { //ì™¼ìª½
        for (int j = 0; j < N; j++) {
          moveElement(i, j, dir, flagMap);
        }
      } else { //dir == 4 (ìœ„ìª½)
        for (int j = 0; j < N; j++) {
          moveElement(j, i, dir, flagMap);
        }
      }
    }
    //debug
//    System.out.println("ë°©í–¥:"+dir+" ê¹Šì´:"+debug);
//    for (int i = 0; i < N; i++) {
//      System.out.println(Arrays.toString(inArr[i]));
//    }
  }

  public static void dfs(int depth) {
    //base condition
    if (depth == MAX_COUNT) {
      int val = 0;
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          val = Math.max(val, inArr[i][j]);
        }
      }
      result = Math.max(val, result);
      return;
    }
    //recursion
    int copy[][] = new int[N + 1][N + 1]; // N ì‘ìœ¼ë‹ˆ ë§¤ë²ˆ ì¬í• ë‹¹
    for(int i=0; i<N; i++) copy[i] = inArr[i].clone(); // 2ì°¨ì› ë°°ì—´ ë³µì œ
    for (int i = 0; i < 4; i++) {
      int dir = i; //ë°©í–¥
      move(dir, depth);
      dfs(depth + 1);
      for(int k=0; k<N; k++) inArr[k] = copy[k].clone(); //backtracking
    }
  }

  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    N = Integer.parseInt(br.readLine());
    inArr = new int[N+1][N+1];
    //input
    for (int i = 0; i < N; i++) {
      StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
      for (int j = 0; j < N; j++) {
        inArr[i][j] = Integer.parseInt(stk.nextToken());
      }
    }
    //debug
//    System.out.println("ì…ë ¥ ê°’");
//    for (int i = 0; i < N; i++) {
//      System.out.println(Arrays.toString(inArr[i]));
//    }
    //run
    dfs(0);
    //output
    System.out.println(result);
  }

}
```

<br><br>

### BFS ë°©ì‹

**ì´ë¯¸ í•©ì¹œ ë¸”ë¡ì¸ì§€ ì²´í¬: Pair ì‚¬ìš©í•œ í’€ì´**

```java
public class BOJ_2048Easy_12100 {
  static int N;
  static Pair[][] map;
  static int result;
  static int[] dx = {0, 1, 0, -1};
  static int[] dy = {1, 0, -1, 0};

  //ë°©í–¥ ëê°€ì§€ ì´ë™ í•¨ìˆ˜(while)
  static void moveElement(int x, int y, Pair[][] board, int dir) {
    int nx = x;
    int ny = y;
    while (true) {
      nx = dx[dir]+nx;
      ny = dy[dir]+ny;
      if(nx<0 || ny<0 || nx>N-1 || ny>N-1) break;
      if (board[nx][ny].val == 0) {
        board[nx][ny].val=board[x][y].val;
        board[nx][ny].sum=board[x][y].sum;
        board[x][y].val=0; board[x][y].sum=false;
      } else if (board[nx][ny].val == board[x][y].val && !board[nx][ny].sum) {
        board[nx][ny].val += board[x][y].val;
        board[nx][ny].sum = true;
        board[x][y].val=0; board[x][y].sum=false;
        break;
      } else { //board[nxt] != board[nxt-1]
        break;
      }
      x=nx;
      y=ny; //ì´ì „ ê¸°ë¡
    }
  }
  //ë°©í–¥ ëê¹Œì§€ ì´ë™ í•¨ìˆ˜(ì¢Œí‘œì„¤ì •)
  static void move(int dir, Pair[][] board) {
    if (dir == 0) { // '->'
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          moveElement(i, N - 1 - j, board, dir);
        }
      }
    }else if (dir == 1) { // 'ì•„ë˜'
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          moveElement(N - 1 - j, i, board, dir);
        }
      }
    }else if (dir == 0) { // '<-'
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          moveElement(i, j, board, dir);
        }
      }
    }else { // 'ìœ„'
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          moveElement(j, i, board, dir);
        }
      }
    }
  }

  static void bfs(Pair[][] board) {
    Queue<Pair[][]> qu = new ArrayDeque<>();
    qu.offer(board);
    int level=0;
    while (!qu.isEmpty()) {
      int size = qu.size();
      level++;
      for (int s = 0; s < size; s++) {
        Pair[][] cur = qu.poll();
        for (int i = 0; i < 4; i++) {
          Pair[][] copy = new Pair[N + 1][N + 1]; //í•­ìƒ ë³µì œë³¸ì„ ë„˜ê²¨ì„œ íì— ë¬¸ì œì—†ì´ ë‹´ëŠ”ë‹¤.
          for (int j = 0; j < N; j++) {
            for (int k = 0; k < N; k++) {
              copy[j][k]=new Pair(cur[j][k].val, false); //false ë¡œ init
            }
          } //ê°„ë‹¨í•œ ë³µì œë©´ clone ë©”ì†Œë“œ ì‚¬ìš© ì¶”ì²œ
          move(i, copy);
//          printAll(level, copy, i); //debug
          qu.offer(copy);
        }
      }
      //base condition
      if (level == 5) {
        while (!qu.isEmpty()) {
          int maxVal=0; //ì œì¼ í° ê°’
          Pair[][] cur = qu.poll();
          for (int j = 0; j < N; j++) {
            for (int k = 0; k < N; k++) {
              maxVal = Math.max(maxVal, cur[j][k].val);
            }
          }
          result = Math.max(result, maxVal);
        }
        break;
      }
    }

  }

  private static void printAll(int depth, Pair[][] copy, int dir) {
    System.out.println("depth:"+ depth);
    System.out.println("dir:"+ dir);
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        System.out.print(copy[i][j]+",");
      }
      System.out.println();
    }
    System.out.println();
  }

  public static void main(String[] args) throws IOException {
    //input
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    N = Integer.parseInt(br.readLine());
    map = new Pair[N+1][N+1];
    for (int i = 0; i < N; i++) {
      StringTokenizer stk = new StringTokenizer(br.readLine(), " ");
      for (int j = 0; j < N; j++) {
        map[i][j] = new Pair(Integer.parseInt(stk.nextToken()), false);
      }
    }
    //run
    bfs(map);
    //output
    System.out.println(result);
  }

  static class Pair {
    int val; boolean sum;

    public Pair(int val, boolean sum) {
      this.val=val; this.sum=sum;
    }

    @Override
    public String toString() {
      return "Pair{" +
          "val=" + val +
          ", sum=" + sum +
          '}';
    }
  }

}
/*
3
2 2 4
0 0 0
0 0 0

3
2 0 0
2 2 0
2 0 0

4
2 4 8 2
2 4 0 0
2 0 0 0
2 0 2 0
 */
```

*<span style="color:#777777">ì£¼ê´€ì ì¸ ìƒê°ì˜ í’€ì´ì´ë¯€ë¡œ í‹€ë¦° ë¶€ë¶„ ì§€ì ì€ ì–¸ì œë‚˜ í™˜ì˜í•©ë‹ˆë‹¤âš¡</span>*
